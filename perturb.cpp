#include <cstdlib> // rand()
#include <vector>
#include <cmath> // ceil()
#include <random>

#include "perturb.hpp"
#include "subsequence.hpp"
#include "solution.hpp"

std::random_device rd;  // Will be used to obtain a seed for the random number engine
std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()

int randomNumber(int lowerLimit, int upperLimit)
{
	std::uniform_int_distribution<> distrib(lowerLimit, upperLimit);

	// Use `distrib` to transform the random unsigned int generated by gen into an int in [lower, upper]
	return distrib(gen);
}

void execDoubleBridge (Solution *s, int fPos, int fSize, int sPos, int sSize)
{
	std::vector<int> firstSeg (fSize);
	for (int i = 0; i < fSize; ++i) {
		firstSeg[i] = s->sequence[fPos +i];
	}

	std::vector<int> secondSeg (sSize);
	for (int i = 0; i < sSize; ++i) {
		secondSeg[i] = s->sequence[sPos +i];
	}

	int smallestSequence = std::min(fSize, sSize);

	for (int i = 0; i < smallestSequence; ++i) {
		std::swap(s->sequence[fPos +i], s->sequence[sPos +i]);
	}

	int diff = fSize - sSize;

	// if the first sequence is bigger
	if (diff > 0) {
		diff = std::abs(diff);

		// toMove stores the elements that haven't been moved from the first sequence
		std::vector<int> toMove (diff);
		int offset = fPos + sSize;
		for (int i = 0; i < diff; ++i) {
			toMove[i] = s->sequence[i + offset];
		}

		// moving all elements diff positions backwards to give room for toMove
		int upper = sPos + sSize;
		for (int i = fPos + fSize; i < upper; ++i) {
			s->sequence[i - diff] = s->sequence[i];
		}

		// inserting toMove
		int insert_offset = sPos + sSize - diff;
		for (int i = 0; i < diff; i++) {
			s->sequence[insert_offset + i] = toMove[i];
		}
	}
	// if the second sequence is bigger
	else if (diff < 0) {
		diff = std::abs(diff);

		std::vector<int> toMove (diff);
		int offset = sPos + fSize;
		for (int i = 0; i < diff; ++i) {
			toMove[i] = s->sequence[i + offset];
		}

		int lower = fPos + fSize;
		for (int i = offset -1; i >= lower; --i) {
			s->sequence[i + diff] = s->sequence[i];
		}

		int insert_offset = fPos + fSize;
		for (int i = 0; i < diff; ++i) {
			s->sequence[insert_offset + i] = toMove[i];
		}
	}
}

/**
 * Implements double bridge movement
 */
Solution perturb (Solution *best, double **costMatrix, std::vector<std::vector<Subsequence>>& subseqMatrix)
{
	// perturb receives best which is different to the solution currently saved in subseqMatrix
	Solution s = *best;

	int dimension = best->sequence.size();
	int range = dimension -1;

	int upperLimit = std::ceil(dimension / 10.);
	int lowerLimit = 2;

	int firstSegSize = randomNumber(lowerLimit, upperLimit);
	int secondSegSize = randomNumber(lowerLimit, upperLimit);

	int firstPos = randomNumber(1, range -firstSegSize);
	int secondPos = randomNumber(1, range -secondSegSize);

	/**
	 * Regenerating secondPos until it is valid. it will be valid only
	 * when the two chosen segments have no intersection
	 */
	while (
		(secondPos <= firstPos && secondPos + secondSegSize > firstPos) ||
		(firstPos <= secondPos && firstPos + firstSegSize > secondPos)
	) {
		secondPos = randomNumber(1, range -secondSegSize);
	}

	// ensures firstPos comes first and secondPos comes after
	if (secondPos < firstPos) {
		// swapping positions
		int aux = firstPos;
		firstPos = secondPos;
		secondPos = aux;

		// swapping sizes
		aux = firstSegSize;
		firstSegSize = secondSegSize;
		secondSegSize = aux;
	}

	execDoubleBridge(&s, firstPos, firstSegSize, secondPos, secondSegSize);

	updateAllSubsequences(&s, costMatrix, subseqMatrix);
	s.cost = subseqMatrix[0][dimension-1].C;

	return s;
}
